# Code Generation Demo

This project demonstrates the usage of two popular code generation tools:
- [oapi-codegen](https://github.com/deepmap/oapi-codegen) for OpenAPI/Swagger code generation
- [sqlc](https://github.com/sqlc-dev/sqlc) for SQL code generation

## Prerequisites

- Docker and Docker Compose
- Make (optional, for local development)

## Project Structure

```
.
├── api/
│   └── spec/
│       └── openapi.yaml    # OpenAPI specification
├── sql/
│   ├── queries/           # SQL queries for sqlc
│   │   └── tasks.sql
│   └── schema.sql         # Database schema
├── generated/
│   ├── api/              # Generated API code (gitignored)
│   └── db/               # Generated database code (gitignored)
├── sqlc.yaml             # sqlc configuration
├── Dockerfile            # Production container definition
├── Dockerfile.dev        # Development container definition
├── docker-compose.yml    # Container orchestration
└── Makefile             # Build and generation commands
```

## Running the Application

### Production Mode

To run the application in production mode:

```bash
docker compose up --build
```

This will:
- Build the Go application container
- Generate all necessary code inside the container
- Start a PostgreSQL database
- Run database migrations
- Start the application server

The API will be available at http://localhost:8080

### Development Mode

To run the application in development mode with hot-reloading:

```bash
docker compose up app-dev
```

This will:
- Mount your local source code into the container
- Generate code on startup
- Run the application with hot-reloading
- Allow you to modify the code and see changes immediately

## API Usage

The API provides the following endpoints:

### Create a Task
```bash
curl -X POST http://localhost:8080/tasks \
  -H "Content-Type: application/json" \
  -d '{
    "title": "My first task",
    "description": "This is a test task"
  }'
```

### List All Tasks
```bash
curl http://localhost:8080/tasks
```

### Get a Specific Task
```bash
# Replace {id} with the actual task ID
curl http://localhost:8080/tasks/{id}
```

## Code Generation

All code generation happens inside Docker containers. The generated code is stored in:
- `generated/api/api.gen.go` (generated by oapi-codegen)
- `generated/db/` (generated by sqlc)

These directories are gitignored as they are generated automatically during the build process.

## Environment Variables

The application can be configured using the following environment variables:

- `DB_HOST` - Database host (default: localhost)
- `DB_PORT` - Database port (default: 5432)
- `DB_USER` - Database user (default: postgres)
- `DB_PASSWORD` - Database password (default: postgres)
- `DB_NAME` - Database name (default: codegen_demo)
- `DB_SSLMODE` - Database SSL mode (default: disable)

## Development Workflow

1. Make changes to:
   - `api/spec/openapi.yaml` for API changes
   - `sql/queries/*.sql` for database query changes
   - `sql/schema.sql` for database schema changes

2. Run the development container:
```bash
docker compose up app-dev
```

3. The container will automatically:
   - Generate new code based on your changes
   - Restart the application
   - Apply database migrations

4. To stop the development environment:
```bash
docker compose down
```

## ORM vs Native SQL

Use case: Get each user's most recent order with user and order details.


### 1. Native SQL

```sql
SELECT u.id AS user_id, u.name, o.id AS order_id, o.amount, o.created_at
FROM users u
JOIN (
    SELECT DISTINCT ON (user_id) *
    FROM orders
    ORDER BY user_id, created_at DESC
) o ON u.id = o.user_id;
```


### 2. SQLAlchemy ORM Version

```python

from sqlalchemy.orm import aliased
from sqlalchemy import func, desc

# Step 1: Define models
class User(Base):
    __tablename__ = 'users'
    id = Column(Integer, primary_key=True)
    name = Column(String)

class Order(Base):
    __tablename__ = 'orders'
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey('users.id'))
    amount = Column(Float)
    created_at = Column(DateTime)

# Step 2: Subquery for latest order per user
subquery = (
    session.query(
        Order.user_id,
        func.max(Order.created_at).label("max_created_at")
    )
    .group_by(Order.user_id)
    .subquery()
)

# Step 3: Join users + orders + subquery to filter only latest
OrderAlias = aliased(Order)
query = (
    session.query(User, OrderAlias)
    .join(OrderAlias, User.id == OrderAlias.user_id)
    .join(subquery, (OrderAlias.user_id == subquery.c.user_id) & (OrderAlias.created_at == subquery.c.max_created_at))
)

results = query.all()

```
